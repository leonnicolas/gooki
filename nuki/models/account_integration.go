// Code generated by go-swagger; DO NOT EDIT.

package models

// This file was generated by the swagger tool.
// Editing this file might prove futile when you re-run the swagger generate command

import (
	"context"
	"encoding/json"

	"github.com/go-openapi/errors"
	"github.com/go-openapi/strfmt"
	"github.com/go-openapi/swag"
	"github.com/go-openapi/validate"
)

// AccountIntegration account integration
//
// swagger:model AccountIntegration
type AccountIntegration struct {

	// The enum advanced state (TESTING e.g.) if this integration is a advanced one
	AdvancedState string `json:"advancedState,omitempty"`

	// The enum advanced type (HEALTHCARE e.g.) if this integration is a advanced one
	AdvancedType string `json:"advancedType,omitempty"`

	// The clientId of this integration/device used for deleting the integration
	// Required: true
	ClientID *string `json:"clientId"`

	// First creation date of the token
	// Format: date-time
	CreatedAt strfmt.DateTime `json:"createdAt,omitempty"`

	// Description given by the user, usually only set for api tokens
	Description string `json:"description,omitempty"`

	// True this is a device and false this is an integration
	Device bool `json:"device,omitempty"`

	// Last refresh date of the token
	// Format: date-time
	LastActiveAt strfmt.DateTime `json:"lastActiveAt,omitempty"`

	// Name of the token
	// Required: true
	Name *string `json:"name"`

	// The scopes which have been granted to the token
	Scopes []string `json:"scopes"`

	// Sort order by which the entry should be sorted, is being set by the vendor key enum
	SortOrder int32 `json:"sortOrder,omitempty"`

	// True if the integration is done via a sub-account
	SubAccount bool `json:"subAccount,omitempty"`

	// Id of the sub-account or null if there is none, which is associated with this token
	SubAccountID int32 `json:"subAccountId,omitempty"`

	// Name of the sub-account or null if there is none, which is associated with this token
	SubAccountName string `json:"subAccountName,omitempty"`

	// The tokenId if this a manual generated api token
	TokenID string `json:"tokenId,omitempty"`

	// Enum key identifying the integration/device, values are e.g. ALEXA, IOS, NUKI_WEB, API_TOKEN etc
	// Required: true
	VendorKey *string `json:"vendorKey"`

	// If the integration/device is an legacy or from the new oauth implementation
	// Required: true
	// Enum: [LEGACY HYDRA]
	Version *string `json:"version"`

	// If this is from a legacy integration this is set to true
	Warning bool `json:"warning,omitempty"`
}

// Validate validates this account integration
func (m *AccountIntegration) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateClientID(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateCreatedAt(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateLastActiveAt(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateName(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateVendorKey(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateVersion(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *AccountIntegration) validateClientID(formats strfmt.Registry) error {

	if err := validate.Required("clientId", "body", m.ClientID); err != nil {
		return err
	}

	return nil
}

func (m *AccountIntegration) validateCreatedAt(formats strfmt.Registry) error {
	if swag.IsZero(m.CreatedAt) { // not required
		return nil
	}

	if err := validate.FormatOf("createdAt", "body", "date-time", m.CreatedAt.String(), formats); err != nil {
		return err
	}

	return nil
}

func (m *AccountIntegration) validateLastActiveAt(formats strfmt.Registry) error {
	if swag.IsZero(m.LastActiveAt) { // not required
		return nil
	}

	if err := validate.FormatOf("lastActiveAt", "body", "date-time", m.LastActiveAt.String(), formats); err != nil {
		return err
	}

	return nil
}

func (m *AccountIntegration) validateName(formats strfmt.Registry) error {

	if err := validate.Required("name", "body", m.Name); err != nil {
		return err
	}

	return nil
}

func (m *AccountIntegration) validateVendorKey(formats strfmt.Registry) error {

	if err := validate.Required("vendorKey", "body", m.VendorKey); err != nil {
		return err
	}

	return nil
}

var accountIntegrationTypeVersionPropEnum []interface{}

func init() {
	var res []string
	if err := json.Unmarshal([]byte(`["LEGACY","HYDRA"]`), &res); err != nil {
		panic(err)
	}
	for _, v := range res {
		accountIntegrationTypeVersionPropEnum = append(accountIntegrationTypeVersionPropEnum, v)
	}
}

const (

	// AccountIntegrationVersionLEGACY captures enum value "LEGACY"
	AccountIntegrationVersionLEGACY string = "LEGACY"

	// AccountIntegrationVersionHYDRA captures enum value "HYDRA"
	AccountIntegrationVersionHYDRA string = "HYDRA"
)

// prop value enum
func (m *AccountIntegration) validateVersionEnum(path, location string, value string) error {
	if err := validate.EnumCase(path, location, value, accountIntegrationTypeVersionPropEnum, true); err != nil {
		return err
	}
	return nil
}

func (m *AccountIntegration) validateVersion(formats strfmt.Registry) error {

	if err := validate.Required("version", "body", m.Version); err != nil {
		return err
	}

	// value enum
	if err := m.validateVersionEnum("version", "body", *m.Version); err != nil {
		return err
	}

	return nil
}

// ContextValidate validates this account integration based on context it is used
func (m *AccountIntegration) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	return nil
}

// MarshalBinary interface implementation
func (m *AccountIntegration) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *AccountIntegration) UnmarshalBinary(b []byte) error {
	var res AccountIntegration
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}
